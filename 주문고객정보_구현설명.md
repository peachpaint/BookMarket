# 주문 고객 정보 자동 입력 구현 (1, 2, 3번 모두 적용)

## 구현된 기능

### ✅ Option 1: Principal에서 로그인 사용자 정보 자동 채우기
- `OrderController.requestCustomerInfoForm()` 메서드에 `Principal` 파라미터 추가
- 로그인된 사용자의 경우 `MemberService.findByMemberId()`로 회원 정보 조회
- `order.setMember(loggedInMember)`로 자동 설정

### ✅ Option 2: 수동 입력 가능하도록 readonly 제거
- `orderCustomerInfo.html`에서 고객 ID 필드의 `readonly` 속성 제거
- 모든 필드를 수정 가능하도록 변경
- placeholder 추가로 사용자 가이드 제공

### ✅ Option 3: 장바구니에서 주문 생성 시 로그인 확인 및 정보 채우기
- `OrderController.requestCartList()` 메서드에 `Principal` 파라미터 추가
- 로그인된 경우 회원 정보를 미리 로드하여 order에 설정
- 로그인하지 않은 경우 빈 Member 객체 생성 (수동 입력 가능)

## 코드 변경 사항

### 1. OrderController.java

#### 변경 사항 1: MemberService 주입
```java
@Autowired
private MemberService memberService;
```

#### 변경 사항 2: requestCartList() - 장바구니에서 주문 생성
```java
@GetMapping("/{cartId}")
public String requestCartList(@PathVariable(value = "cartId") String cartId, Principal principal, Model model) {
    // ... 장바구니 아이템 처리 코드 ...
    
    // Option 3: 로그인된 사용자 정보로 초기화
    if (principal != null) {
        try {
            Member loggedInMember = memberService.findByMemberId(principal.getName());
            order.setMember(loggedInMember);
        } catch (IllegalArgumentException e) {
            order.setMember(new Member());
        }
    } else {
        // 로그인하지 않은 경우 빈 Member 객체 생성 (수동 입력 가능)
        order.setMember(new Member());
    }
    
    order.setDelivery(new Delivery());
    return "redirect:/orders/orderCustomerInfo";
}
```

#### 변경 사항 3: requestCustomerInfoForm() - 고객 정보 입력 폼
```java
@GetMapping("/orderCustomerInfo")
public String requestCustomerInfoForm(Principal principal, Model model) {
    // Option 1: 이미 order에 member가 설정되어 있지 않거나 비어있는 경우, Principal에서 다시 가져오기
    if (principal != null && (order.getMember() == null || order.getMember().getMemberId() == null)) {
        try {
            Member loggedInMember = memberService.findByMemberId(principal.getName());
            order.setMember(loggedInMember);
        } catch (IllegalArgumentException e) {
            // 회원 정보를 찾을 수 없는 경우 빈 Member 객체 유지
        }
    }
    
    // member 정보가 여전히 없으면 빈 객체 생성
    if (order.getMember() == null) {
        order.setMember(new Member());
    }
    
    model.addAttribute("member", order.getMember());
    model.addAttribute("isLoggedIn", principal != null);
    return "orderCustomerInfo";
}
```

### 2. orderCustomerInfo.html

#### 변경 사항: 로그인 상태 표시 및 readonly 제거
```html
<!-- 로그인 상태 표시 -->
<div class="alert alert-info" th:if="${isLoggedIn}">
    로그인된 사용자 정보가 자동으로 입력되었습니다. 필요시 수정 가능합니다.
</div>
<div class="alert alert-warning" th:unless="${isLoggedIn}">
    로그인하지 않은 상태입니다. 고객 정보를 직접 입력해주세요.
</div>

<!-- Option 2: readonly 제거하여 수동 입력 가능 -->
<div class="mb-3 row">
    <label class="col-sm-2 col-form-label">고객 ID</label>
    <div class="col-sm-10">
        <input type="text" name="memberId" class="form-control" th:field="*{memberId}" 
               placeholder="고객 ID를 입력하세요" required/>
        <small class="form-text text-muted">로그인된 경우 자동으로 입력되며, 수정도 가능합니다.</small>
    </div>
</div>
```

## 동작 흐름

### 시나리오 1: 로그인된 사용자
1. 사용자가 로그인 상태로 장바구니에서 "주문하기" 클릭
2. `requestCartList()`에서 `Principal`을 통해 로그인 사용자 확인
3. `MemberService.findByMemberId()`로 회원 정보 조회
4. `order.setMember(loggedInMember)`로 자동 설정
5. 고객 정보 페이지로 리다이렉트
6. `requestCustomerInfoForm()`에서 이미 설정된 Member 정보 사용
7. HTML 폼에 고객 ID, 이름, 전화번호, 거주지 자동 입력
8. 파란색 알림 표시: "로그인된 사용자 정보가 자동으로 입력되었습니다"
9. **사용자는 자동 입력된 정보를 그대로 사용하거나 수정 가능**

### 시나리오 2: 로그인하지 않은 사용자
1. 사용자가 비로그인 상태로 장바구니에서 "주문하기" 클릭
2. `requestCartList()`에서 `Principal`이 null
3. `order.setMember(new Member())`로 빈 객체 생성
4. 고객 정보 페이지로 리다이렉트
5. `requestCustomerInfoForm()`에서 빈 Member 객체 사용
6. HTML 폼에 모든 필드가 비어있음
7. 노란색 알림 표시: "로그인하지 않은 상태입니다. 고객 정보를 직접 입력해주세요"
8. **사용자는 모든 정보를 수동으로 입력**

### 시나리오 3: 로그인했지만 URL 직접 접근
1. 사용자가 로그인 상태에서 `/orders/orderCustomerInfo`로 직접 접근
2. `requestCustomerInfoForm()`에서 `order.getMember()`가 null이거나 memberId가 null
3. `Principal`에서 로그인 사용자 정보 다시 조회
4. `order.setMember(loggedInMember)`로 설정
5. HTML 폼에 자동 입력
6. **이중 체크로 로그인 사용자는 항상 정보가 자동 입력됨**

## 주요 특징

### 1. 유연성 (Flexibility)
- 로그인된 사용자: 자동 입력 + 수정 가능
- 비로그인 사용자: 전체 수동 입력 가능
- 게스트 주문과 회원 주문 모두 지원

### 2. 사용자 경험 (UX)
- 로그인 상태에 따른 명확한 안내 메시지
- 자동 입력된 정보 수정 가능 (오타 정정, 다른 정보 입력 등)
- placeholder로 입력 가이드 제공

### 3. 보안성 (Security)
- Spring Security의 Principal을 통한 안전한 인증 정보 접근
- MemberService를 통한 데이터베이스 조회로 신뢰성 확보
- 예외 처리로 회원 정보 조회 실패 시에도 정상 동작

### 4. 이중 체크 (Double Check)
- `requestCartList()`에서 1차 설정
- `requestCustomerInfoForm()`에서 2차 확인 및 설정
- URL 직접 접근이나 세션 문제 발생 시에도 안전

## 테스트 방법

### 테스트 1: 로그인 후 주문
```
1. /login으로 로그인
2. /books로 이동하여 책 선택
3. 장바구니에 추가
4. /cart에서 "주문하기" 클릭
5. 고객 정보 페이지에서 자동 입력 확인
6. 파란색 알림 메시지 확인
7. 필드 수정 가능 여부 확인
```

### 테스트 2: 비로그인 주문
```
1. 로그아웃 또는 로그인하지 않음
2. /books로 이동하여 책 선택
3. 장바구니에 추가
4. /cart에서 "주문하기" 클릭
5. 고객 정보 페이지에서 빈 필드 확인
6. 노란색 알림 메시지 확인
7. 정보 수동 입력
```

### 테스트 3: URL 직접 접근
```
1. /login으로 로그인
2. 브라우저 주소창에 /BookMarket/orders/orderCustomerInfo 직접 입력
3. 고객 정보가 자동으로 입력되는지 확인
4. (order 객체가 없으면 오류 발생 가능 - 이 경우 장바구니를 거쳐야 함)
```

## 추가 개선 사항 (선택사항)

### 1. 로그인 필수 옵션
만약 회원만 주문 가능하도록 하려면:
```java
@GetMapping("/{cartId}")
public String requestCartList(@PathVariable(value = "cartId") String cartId, Principal principal, Model model) {
    // 로그인 체크
    if (principal == null) {
        return "redirect:/login?returnUrl=/orders/" + cartId;
    }
    // ... 나머지 코드 ...
}
```

### 2. 게스트 주문 번호 자동 생성
비로그인 사용자를 위한 게스트 ID 자동 생성:
```java
if (principal == null) {
    Member guestMember = new Member();
    guestMember.setMemberId("GUEST_" + System.currentTimeMillis());
    order.setMember(guestMember);
}
```

### 3. 세션 저장
`order` 객체를 컨트롤러 필드가 아닌 세션에 저장하여 멀티 유저 환경 지원:
```java
@GetMapping("/{cartId}")
public String requestCartList(@PathVariable(value = "cartId") String cartId, 
                              Principal principal, HttpSession session) {
    Order order = new Order();
    // ... order 설정 ...
    session.setAttribute("currentOrder", order);
    return "redirect:/orders/orderCustomerInfo";
}
```

## 결론

이제 주문 시스템은:
- ✅ **Option 1**: 로그인 사용자 정보 자동 채우기
- ✅ **Option 2**: 수동 입력 및 수정 가능
- ✅ **Option 3**: 장바구니에서 주문 생성 시 사전 로드

세 가지 옵션을 모두 지원하여 **최대한 유연하고 사용자 친화적인 주문 프로세스**를 제공합니다.
